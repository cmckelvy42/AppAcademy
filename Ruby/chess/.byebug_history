c
e
c
quit
@board[adv2.xy]
n
@board[adv1.xy]
n
c
C
c
side_attacks
c
@display
@displayh
@board.rows.flatten.reject{|e| e == NullPiece.instance}
@board.rows.flatten.reject(&:@board.empty?)
@board.rows
@board.pieces
pos
c
moves
pos
c
pos
c
@pos
c
@board[start_pos].moves
b Pawn#side_attacks
@board[start_pos].moves
c
e
c
e
c
e
end_pos
@board[start_pos].moves
@board[start_pos].at_start_row?
@board[start_pos].pos
@board[start_pos]
self.board
self
@board.pieces
e
quit
c
quit
c
@pos
at_start_row?
c
load "game.rb"
e.message
e
c
e
c
e
quit
e
quit
c
cc
c
n
quit
e.message
n
c
q
n
tmpPiece
n
end_pos
pos
tmp
s
n
s
move
pos
c
tmp[1].valid_moves
tmp = pieces.select{|p| p.color == color}
b Piece#valid_moves
c
n
ret
n
self
n
valid_moves
moves
self
c
b Piece#valid_moves
load "pieces/piece.rb"
quit
check?(tmp[1].color)
check?(tmp.color)
move_piece(tmppos, [1,5])
tmpPiece
tmpPiece = self[[1,5]]
tmpPiece = @board[[1,5]]
tmppos = tmp[1].pos
tmp[1].valid_moves
check?(:light_yellow)
tmp[1].moves
tmp = pieces.select{|p| p.color == color}
q
self[[2,7]].color
self[2,7].color
tmp[1].moves
tmp = pieces.select{|p| p.color == color}
q
tmp[1].moves
tmp[0].moves
tmp = pieces.select{|p| p.color == color}
quit
tmp[0].moves
tmp[1].moves
tmp[1]
pieces
tmp[1].valid_moves[0]
tmp[1].valid_moves
tmp[1]
pieces
tmp[1].valid_moves
tmp = pieces.select{|p| p.color == color}
quit
pieces
check?(:light_yellow)
tmp[1].valid_moves
tmp = pieces.select{|p| p.color == color}
quit
tmp[1].valid_moves
tmp[9].valid_moves
tmp = pieces.select{|p| p.color == color}
quit
tmp[9].valid_moves
tmp[8].valid_moves
tmp[9].valid_moves
tmp[9]
pieces[1]
pieces[1].valid_moves
pieces[0].valid_moves
pieces[8].valid_moves
pieces[9].valid_moves
tmp.reject{|p| p.valid_moves.empty?}
tmp
tmp.select{|p| p.valid_moves.size > 0}
tmp.any?{|p| p.valid_moves.size > 0}
tmp.any?{|p| p.valid_moves.empty?}
tmp.all?{|p| p.valid_moves.empty?}
tmp.select{|p| p.valid_moves.size > 0}
tmp = pieces.select{|p| p.color == color}
color
c
q
c
n
valid_moves
c
quit
pieces
check?(:light_yellow)
s
n
c
@pos
loc
quit
c
quit
c
quit
end_pos
end_pos.xy
pos.xy
tmp.xy
c
quit
m
c
tmp[10].pos
tmp[9].pos
tmp[8].pos
tmp[0].pos
tmp[0]
tmp.all?{|p| p.valid_moves.size == 0}
tmp = pieces.select{|p| p.color == color}
pieces.select{|p| p.color == color}
pieces
pieces.select{|p| p.color == color}.all?{|p| p.valid_moves.empty?}
n
quit
c
color
c
self
c
self
c
self
c
n
s
n
s p.valid_moves
p.valid_moves
b Piece#valid_moves
p.valid_moves
b Piece#move_into_check?
p.valid_moves
p = pieces[24]
c
b Piece#move_into_check?
b
b "pieces/piece.rb" 33
b
p.move_into_check?([0,5])
p.move_into_check([0,5])
check?(:light_yellow)
move_piece([0,5], tmp)
check?(:light_yellow)
move_piece(tmp, p.valid_moves[0])
tmp = p.pos
p.valid_moves
p = pieces[24]
c
quit
c
d
check?(:light_yellow)
move_piece( [0,5],[2,7])
check?(:light_yellow)
move_piece(p.pos, [0,5])
p.valid_moves
p.moves
p = pieces.select{|p| p.color == color}[9]
pieces.select{|p| p.color == color}[9].move_into_check?([0,5])
pieces.select{|p| p.color == color}[9].valid_moves
pieces.select{|p| p.color == color}.select{|p| p.valid_moves.size > 0}
pieces.select{|p| p.color == color}
pieces.select{|p| p.color != color}
pieces[0].valid_moves
pieces[0]
pieces.select{|p| p.valid_moves.size > 0}
n
check?(:light_yellow)
quit
c
(@notifications[:check])
@notifications[:check] == true
